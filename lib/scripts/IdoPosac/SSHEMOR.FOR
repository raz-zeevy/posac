
CY$STORAGE:2
      PROGRAM SHEMOR
C
C**********************************************************************
C
C  THIS PROGRAM ADDS 4 VARIABLES TO DATAFILE OLDDAT TO CREATE
C  A NEW DATAFILE NEWDAT . THESE 4 VARIABLES COME FROM POSAC RUN .
C  THEY ARE THE BASE AND TRANSFORMED COORDINATES .
C    BASE        :  X  AND  Y
C    TRANSFORMED :  J  AND  L  (JOINT  AND  LATERAL)
C  THE 4 NEW VARIABLES CAN BE RECODED . THEY ARE ADDED ON A NEW RECORD
C  THAT IS TO SAY IF OLDDAT CONTAINS NR RECORDS NEWDAT WILL CONTAIN
C  (NR+1) RECORDS. THE FORMAT ON THE NEW RECORD IS 4I3
C
C**********************************************************************
C
C      HOW TO USE THE PROGRAM ?
C
C  THIS PROGRAM IS RUN AFTER PROGRAM 'POSAC' . THERE IS NO SENSE TO RUN
C  IT BY ITSELF BECAUSE IT GETS ITS INFORMATION FROM 'POSAC'
C  THE DIRECTIVES ARE TRANSMITTED TO 'SHEMOR' BY SENTENCES 
C  FOLLOWING A LINE CONTAINING "SHEMOR" IN COLUMNS 1-6 OF THE POSAC
C  INSTRUCTION FILE.
C
C  THE FIRST SENTENCE INDICATES THE RECORD LENGTH OF RAW DATA 'OLDDAT'
C  FOR EXAMPLE :
C      RECORD LENGTH   120
C  IF SUCH A SENTENCE IS ABSENT THE DEFAULT IS 80
C
C  THE FOLLOWING SENTENCES INDICATE THE RECODING OF THE ORIGINAL
C  COORDINATES  X Y J L  BEFORE THEY ARE ADDED TO RAW DATA
C  THE TYPE OF SUCH A SENTENCE IS :
C
C   FOR V1,V2,...  RECODE  N11 THRU  N12 = L1, N21 THRU N22=L2 ,
C      N31 THRU N32 =L3 , .........   , NM1 THRU NM2 = LM .
C
C  WHERE :
C    THE VARIABLE LIST V1,V2,... IS THE LIST X,Y,J,L OR A PART OF IT
C    THE NUMBERS NI1,NI2,LI (I=1,...,M) ARE INTEGER NUMBERS
C  FOR EXAMPLE :
C
C    FOR X,Y RECODE  0 THRU 45 = 1, 46 THRU 75 =2, 76 THRU 100= 3.
C   FOR J RECODE 0 THRU 60 =1 , 61 THRU 110 =2,111 THRU 150 = 3,
C                151 THRU 200 = 4 .
C      FOR L  RECODE 0 THRU 100 =1 , 101 THRU 200 = 2 .
C
C  HERE ALSO THERE ARE DEFAULTS :
C
C  FOR X,Y RECODE   0 THRU  25 = 1 ,  26 THRU  50 = 2 ,
C                  51 THRU  75 = 3 ,  76 THRU 100 = 4 .
C
C  FOR J,L RECODE   0 THRU  50 = 1 ,  51 THRU 100 = 2 ,
C                 101 THRU 150 = 3 , 151 THRU 200 = 4 .
C
C************************************************************************
C
C  IN THE C.D.C COMPUTER OF THE HEBREW UNIVERSITY OF JERUSALEM
C  THE RAW DATA HAVE TO BE ON TAPE6 (OLDDAT) . THE NEW DATA ARE
C  WRITTEN ON TAPE20 (NEWDAT) .
C
C************************************************************************
C
C  PROGRAM WRITTEN BY 'AMAR REUBEN IN FORTARN 77
C
C************************************************************************

      IMPLICIT INTEGER*2  (I-N)
INCLUDE 'MPARMLIN'
      COMMON XX1 (MNV), XN1 (MNV), XN2 (MNV), XN3 (MNV, MIEND),
     $        XN4 (MNV), XN5 (4, MIEND)
      INTEGER*2 XX1, XN1, XN2, XN3, XN4
      REAL   XN5

      COMMON/DIM/N1,N2,N3,N4,N5,N6
      COMMON/IO/NREAD,NWRITE,INDIC
      COMMON/PARAM/NV,IDATA,NXT,ITABLE,INTERN,NP,IFSHMR
      COMMON/TAPDAT/OLDDAT,NEWDAT
      INTEGER*2  OLDDAT,NEWDAT
C  TAPE ASSIGNMENTS
C
C  GETTING INFORMATION FROM POSAC
      CALL OPENFILE
C
      CALL INFORM
C
C  READ DIRECTIVES FOR PROGRAM SHEMOR
C
      CALL DIREC
C
C  SEARCHING INDEXES OF INTERNAL VARIABLES
      CALL SINT (XX1, XN1)
C
C  ADDING TO EACH CASE BASE AND TRANSFORMED COORDINATES WITH
C  EVENTUALLY RECODING OF CATEGORIES
      CALL ADDVAR (XX1, XN1, XN2, XN3, XN4, XN5, NV, INTERN, NP, IDATA)
C
      WRITE (*,*) CHAR (7), CHAR (7)
      STOP 'New Data File Created'
      END

      SUBROUTINE INFORM
C
      IMPLICIT INTEGER*2  (I-N)
      PARAMETER (LENFOR=255)
C
C  READS INFORMATION WHICH WERE WRITTEN ON UNIT INDIC BY
C  PROGRAM POSAC.

INCLUDE 'MPARMLIN'
      COMMON XX1 (MNV), XN1 (MNV), XN2 (MNV), XN3 (MNV, MIEND),
     $        XN4 (MNV), XN5 (4, MIEND)
      INTEGER*2 XX1, XN1, XN2, XN3, XN4
      REAL   XN5

      COMMON/PARAM/NV,IDATA,NXT,ITABLE,INTERN,NP,IFSHMR
      COMMON/IO/NREAD,NWRITE,INDIC
      COMMON/FRM/FOR
      COMMON/KENID/YESID
      COMMON/TAPDAT/OLDDAT,NEWDAT
      CHARACTER FOR*(LENFOR)
      LOGICAL YESID
      INTEGER*2 OLDDAT
      REWIND INDIC
C
C  HERE WE READ FROM UNIT INDIC THE INFORMATION
C  WE NEED TO PROCESS THIS PROGRAM
      READ(INDIC) NV,OLDDAT,IDATA,NXT,ITABLE,INTERN,IFSHMR
      READ(INDIC) FOR,YESID
      IF(NXT.NE.0) CALL REXTVR (XX1, NXT)
      IF(ITABLE.NE.0) THEN
          WRITE (*,*) 'SHEMOR run by mistake.', CHAR (7)
          STOP
      ELSE
          READ(INDIC) NP
          INTERN=NV-NXT
C
          CALL RPROF (XN3, XN4, XN5, INTERN, NP)
      ENDIF
      RETURN
      END

      SUBROUTINE DIREC
C  THIS SUB. READS DIRECTIVES FOR PROGRAM SHEMOR
      IMPLICIT INTEGER*2  (I-N)
      COMMON/IO/NREAD,NWRITE,INDIC
      COMMON/CATGR/L1(4,50),L2(4,50),IVAL(4,50),NPT(4),IC(4)
      COMMON/PARAM/NV,IDATA,NXT,ITABLE,INTERN,NP,IFSHMR
      COMMON/RECORD/LR,NR
      CHARACTER LINE*80,WCHAR*2
      LOGICAL TEST
      TEST=.TRUE.
C
C  DEFAULT VALUES
      CALL DEFAUL
C
      IF (IFSHMR .EQ. 0) THEN
          WRITE (NWRITE, *) ' USING DEFAULT RECODING VALUES.'
          GOTO 150
      END IF
C
      WRITE(NWRITE,400)
C
 5    READ(NREAD,'(A)',END=50) LINE
      IF (LINE (1:6) .NE. 'SHEMOR' .AND. LINE (1:6) .NE. 'shemor')
     $       GOTO 5
C
C  DETECT IF A RECORD LENGTH IS GIVEN
C
      READ(NREAD,'(A)',END=100) LINE
      TEST=.FALSE.
      WRITE(NWRITE,'(1X,A)') LINE
      I=INDEX(LINE,'LENGTH')
      IF(I.NE.0) THEN
          K1=I+6
          WRITE(WCHAR,'(I2)') 80-K1+1
          READ(LINE(K1:),'(I'//WCHAR//')',ERR=200) LR
      ENDIF
C
      CALL RECODE(LINE)
  100 CONTINUE
      IF(TEST) WRITE(NWRITE,700)
      WRITE(NWRITE,500) LR
  150 WRITE(NWRITE,600)
      DO 10 I=1,4
         IF(I.EQ.1) WCHAR=' X'
         IF(I.EQ.2) WCHAR=' Y'
         IF(I.EQ.3) WCHAR=' J'
         IF(I.EQ.4) WCHAR=' L'
         NPE=NPT(I)
         WRITE(NWRITE,300) WCHAR,(L1(I,J),L2(I,J),IVAL(I,J),
     $                            J=1,NPE)
   10 CONTINUE
      RETURN
C
   50 WRITE (NWRITE,*) ' REQUIRED DIRECTIVES FOR SHEMOR NOT FOUND.'
      WRITE (*,*) CHAR (7)
      STOP
C
  200 WRITE(NWRITE,*) ' SYNTAX ERROR : INTEGER NUMBER MUST',
     $                ' APPEAR FOR LR '
  300 FORMAT(' FOR',A2,' RECODING IS : ',
     $ 5(1X,I3,' THRU ',I3,' = ',I3,:,' ,'))
  400 FORMAT(//,' INPUT DIRECTIVES OF PROGRAM SHEMOR',
     $ /,1X,34(1H-),/)
  500 FORMAT(//,' THE RECORD LENGTH IS : ',I3)
  600 FORMAT(/,' CATEGORY RECODING',/,1X,17(1H-))
  700 FORMAT(12X,'E M P T Y')
      END

      SUBROUTINE DEFAUL
C  THIS SUB. ASSIGNS DEFAULT VALUES TO
C   LR : RECORD LENGTH
C   AND RECODING CATEGORIES
      IMPLICIT INTEGER*2  (I-N)
      COMMON/CATGR/L1(4,50),L2(4,50),IVAL(4,50),NPT(4),IC(4)
      COMMON/RECORD/LR,NR
C
      LR=80
C
C  4 CATEGORIES TO EACH OF X,Y,J,L
      DO 10 I=1,4
   10    NPT(I)=4
C
C  FOR X AND Y INTERVAL=25 . FOR J AND L INTERVAL=50
      DO 20 I=1,4
         INTRV=25
         IF(I.EQ.3.OR.I.EQ.4) INTRV=50
         DO 30 J=1,4
            L1(I,J)=(J-1)*INTRV+1
            L2(I,J)=J*INTRV
            IVAL(I,J)=J
   30    CONTINUE
         L1(I,1)=0
   20 CONTINUE
      RETURN
      END

      SUBROUTINE REXTVR(EXTVAR,NXT)
C  READS SERIAL NUMBER OF EXTERNAL VARIABLES
      IMPLICIT INTEGER*2  (I-N)
      COMMON/IO/NREAD,NWRITE,INDIC
      INTEGER*2 EXTVAR(NXT)
      READ(INDIC) (EXTVAR(I),I=1,NXT)
      RETURN
      END
	  
      SUBROUTINE RPROF(IPRF,ISCO,XYJL,INTERN,NP)
C  THIS SUB. READS PROFILES , SCORES AND COORDINATES
C  FROM UNIT INDIC (FROM PROGRAM POSAC)
      IMPLICIT INTEGER*2  (I-N)
      COMMON/IO/NREAD,NWRITE,INDIC
      DIMENSION IPRF(INTERN,NP),ISCO(NP),XYJL(4,NP)
      DO 10 I=1,NP
         READ(INDIC) (IPRF(J,I),J=1,INTERN),ISCO(I),
     $                (XYJL(J,I),J=1,4)
   10 CONTINUE
      RETURN
      END

      SUBROUTINE SINT(EXTVAR,INTVAR)
C  SEARCHES SERIAL NUMBER OF INTERNAL VARIABLES
C  THE INDEXES OF INTERNAL VARIABLES ARE
C  STORED IN INTVAR
      IMPLICIT INTEGER*2  (I-N)
      INTEGER*2 EXTVAR(*),INTVAR(*)
      COMMON/PARAM/NV,IDATA,NXT,ITABLE,INTERN,NP,IFSHMR
      COMMON/IO/NREAD,NWRITE,INDIC
      INT=0
      DO 10 I=1,NV
         DO 20 J=1,NXT
            IF(EXTVAR(J).EQ.I) GO TO 10
   20    CONTINUE
         INT=INT+1
         INTVAR(INT)=I
   10 CONTINUE
      IF(INT.NE.INTERN) THEN
          WRITE(NWRITE,*) ' **ERROR** NO FIT FOR INTERN. VAR. '
          WRITE (*,*) CHAR (7)
          STOP
      ELSE
          RETURN
      ENDIF
      END

      SUBROUTINE ADDVAR(IREAD,INTVAR,IWORK,IPRF,ISCO,
     $                  XYJL,NV,INTERN,NP,IDATA)
C  THIS SUB. ANALYSES EACH CASE IN THE RAW DATA
C  TO SEE IF IT WAS RETAINED . IF YES THE 4 VARIABLES X Y J L
C  FROM POSAC ARE ADDED TO THIS CASE .
C      RECODING VALUES ARE ALSO PERMITTED :
C   FOR X   L1(1,.) THRU  L2(1,.) = IVAL(1,.)
C   FOR Y   L1(2,.) THRU  L2(2,.) = IVAL(2,.)
C   FOR J   L1(3,.) THRU  L2(3,.) = IVAL(3,.)
C   FOR L   L1(4,.) THRU  L2(4,.) = IVAL(4,.)
      IMPLICIT INTEGER*2  (I-N)
      PARAMETER (LENFOR=255)
      COMMON/FRM/FOR
      COMMON/KENID/YESID
      COMMON/CATGR/L1(4,50),L2(4,50),IVAL(4,50),NPT(4),IC(4)
      COMMON/IO/NREAD,NWRITE,INDIC
      COMMON/RECORD/LR,NR
      COMMON/TAPDAT/OLDDAT,NEWDAT
      INTEGER*2 OLDDAT
      CHARACTER FOR*(LENFOR), LINE*150
      LOGICAL YESID
      CHARACTER*8 ID
C   ID  :  DUMMY IDENTIFICATION
      DIMENSION INTVAR(NV),IPRF(INTERN,NP),ISCO(NP),
     $          IREAD(NV),IWORK(NV),XYJL(4,NP)
      REWIND OLDDAT
      REWIND INDIC
C
      NCAS=0
C  READ A NEW CASE
  400 CONTINUE
C*    READ(OLDDAT,FOR,END=100) (IREAD(I),I=1,NV)
      IF (YESID) THEN
      IF (IDATA.EQ.0) READ(OLDDAT,FOR,END=100) ID,(IREAD(I),I=1,NV)
      IF (IDATA.NE.0) READ(OLDDAT,FOR,END=100) ID,IFREQ,
     $                                            (IREAD(I),I=1,NV)
           ELSE
      IF (IDATA.EQ.0) READ(OLDDAT,FOR,END=100) (IREAD(I),I=1,NV)
      IF (IDATA.NE.0) READ(OLDDAT,FOR,END=100) IFREQ,(IREAD(I),I=1,NV)
      ENDIF
      NCAS=NCAS+1
C  SELECT INTERNAL VARIABLES AND COMPUTE SCORE OF CASE
      ISCASE=0
      DO 10 I=1,INTERN
         IW=IREAD(INTVAR(I))
         IWORK(I)=IW
         ISCASE=ISCASE+IW
   10 CONTINUE
C  IN LIST OF PROFILES SELECT THOSE WHICH HAVE SCORE ISCASE
C  TO DO THE COMPARISON OF CASE WITH PROFILE FASTER
C
C  SELECT INDEXES I1,I2 OF PROFILES WITH SCORE=ISCASE
      DO 20 I=1,NP
         ISPROF=ISCO(I)
         IF(ISCASE.GT.ISPROF) GO TO 200
         IF(ISCASE.EQ.ISPROF) THEN
             I1=I
             I2=I1
             GO TO 30
         ENDIF
   20 CONTINUE
      GO TO 200
   30 CONTINUE
      I11=I1+1
      IF(I1.EQ.NP) GO TO 250
      DO 40 I=I11,NP
         IF(ISCASE.GT.ISCO(I)) GO TO 250
         I2=I
   40 CONTINUE
C  NOW SELECTNG PROFILE EQUAL TO CASE
  250 CONTINUE
      DO 50 I=I1,I2
         DO 60 J=1,INTERN
            IF(IWORK(J).NE.IPRF(J,I)) GO TO 50
   60    CONTINUE
C        HERE CASE = PROFILE
         IP=I
         GO TO 300
   50 CONTINUE
  200 CONTINUE
C  HERE THE CASE HAS MISSING COORDINATES
      DO 70 I=1,4
   70    IC(I)=0
      GO TO 350
  300 CONTINUE
C  FINDING RECODED CATEGORIES IC(I) FROM X Y J L
      DO 80 I=1,4
   80    IC(I)=XYJL(I,IP)+.5
      DO 90 I=1,4
         ICI=IC(I)
         DO 110 J=1,NPT(I)
            IF(ICI.GE.L1(I,J).AND.ICI.LE.L2(I,J))
     $                  IC(I)=IVAL(I,J)
  110    CONTINUE
   90 CONTINUE
  350 CONTINUE
C
C  NOW WRITING NEW VARIABLES IC(.) ON UNIT INDIC
C
      WRITE(INDIC) (IC(I),I=1,4)
C  READ A NEW CASE
      GO TO 400
  100 CONTINUE
C
C  COMPUTING NUMBER OF RECORDS IN FILE OLDDAT
      REWIND OLDDAT
      NRF=0
  115 CONTINUE
      READ(OLDDAT,'(A)',END=116) LINE(1:1)
      NRF=NRF+1
      GO TO 115
  116 CONTINUE
C  COMPUTING NR : NUMBER OF RECORDS PER CASE
      NR=FLOAT(NRF)/NCAS+.5
      WRITE(NWRITE,150) NR
C
C  NOW MERGING RAW DAT WITH NEW DATA
      REWIND INDIC
      REWIND NEWDAT
      REWIND OLDDAT
      DO 140 NC=1,NCAS
         DO 120 I=1,NR
            READ (OLDDAT,'(A)') LINE(:LR)
            WRITE(NEWDAT,'(A)') LINE(:LR)
  120    CONTINUE
         READ (INDIC)          (IC(I),I=1,4)
         WRITE(NEWDAT,'(4I3)') (IC(I),I=1,4)
  140 CONTINUE
      RETURN
  150 FORMAT(/,' THE COMPUTED NUMBER OF RECORDS PER CASE IS : ',I3)
      END

      SUBROUTINE RECODE(LINE)
      IMPLICIT INTEGER*2  (I-N)
C  THIS SUB. PROCESSES INPUT DIRECTIVES FOR
C  RECODING POSAC COORDINATES
      COMMON/IO/NREAD,NWRITE,INDIC
      COMMON/CATGR/L1(4,50),L2(4,50),IVAL(4,50),NPT(4),IC(4)
      DIMENSION IEXIST(4)
      CHARACTER LINE*(*),WCHAR*2
C
C  THE SIGNIFICANT KEYWORDS ARE
C   'FOR','RECODE','THRU'
C   'X','Y','J','L' ARE RESERVED LETTERS MEANING
C    COORDINATES : X,Y,J,L
C  THE SIGNIFICANT SYMBOLS ARE ',','.','='
   20 CONTINUE
      DO 10 J=1,4
   10    IEXIST(J)=0
      I=INDEX(LINE,'FOR')
      IF(I.EQ.0) THEN
         READ(NREAD,'(A)',END=100) LINE
         WRITE(NWRITE,'(1X,A)') LINE
         GO TO 20
      ENDIF
      K1=I+3
      I=INDEX(LINE(K1:),'X')
      IF(I.NE.0) IEXIST(1)=1
      I=INDEX(LINE(K1:),'Y')
      IF(I.NE.0) IEXIST(2)=1
      I=INDEX(LINE(K1:),'J')
      IF(I.NE.0) IEXIST(3)=1
      I=INDEX(LINE(K1:),'L')
      IF(I.NE.0) IEXIST(4)=1
C  TESTING IF AT LEAST ONE OF X,Y,J,L EXISTS
      IS=0
      DO 30 J=1,4
   30    IS=IS+IEXIST(J)
      IF(IS.EQ.0) THEN
          WRITE(NWRITE,*) ' SYNTAX ERROR : AT LEAST ONE OF THE LETTERS'
          WRITE(NWRITE,*) '   ''X,Y,J,L'' MUST APPEAR AFTER ''FOR'''
          WRITE (*,*) CHAR (7)
          STOP
      ENDIF
   40 CONTINUE
      I=INDEX(LINE(K1:),'RECODE')
      IF(I.EQ.0) THEN
         READ(NREAD,'(A)',END=100) LINE
         WRITE(NWRITE,'(1X,A)') LINE
         K1=1
         GO TO 40
      ENDIF
      NP=0
      I=I+K1-1
      K1=I+6
   50 CONTINUE
      I=INDEX(LINE(K1:),'THRU')
      IF(I.EQ.0) THEN
         READ(NREAD,'(A)',END=100) LINE
         WRITE(NWRITE,'(1X,A)') LINE
         K1=1
         GO TO 50
      ENDIF
      I=I+K1-1
      WRITE(WCHAR,'(I2)') I-K1
      READ(LINE(K1:I),'(I'//WCHAR//')',ERR=200) LV1
      K1=I+4
      I=INDEX(LINE(K1:),'=')
      IF(I.EQ.0) THEN
          WRITE(NWRITE,*) ' SYNTAX ERROR : FOR ONE RECODING ''='' MUST'
          WRITE(NWRITE,*) '   APPEAR WITH ''THRU'' ON THE SAME LINE'
          WRITE (*,*) CHAR (7) 
          STOP
      ENDIF
      I=I+K1-1
      WRITE(WCHAR,'(I2)') I-K1
      READ(LINE(K1:I),'(I'//WCHAR//')',ERR=200) LV2
      K1=I+1
      I=INDEX(LINE(K1:),',')
      IP=0
      IF(I.EQ.0) THEN
          IP=INDEX(LINE(K1:),'.')
          IF(IP.EQ.0) THEN
             WRITE(NWRITE,*) ' ERROR : MISSING SEPARATOR '','' OR ''.'''
             WRITE (*,*) CHAR (7) 
             STOP
          ENDIF
      ENDIF
      I=I+K1-1
      IP=IP+K1-1
      K2=MAX0(I,IP)
      WRITE(WCHAR,'(I2)') K2-K1
      READ(LINE(K1:K2),'(I'//WCHAR//')',ERR=200) IVL
      NP=NP+1
      DO 60 J=1,4
         IF(IEXIST(J).EQ.0) GO TO 60
         NPT(J)=NP
         L1(J,NP)=LV1
         L2(J,NP)=LV2
         IVAL(J,NP)=IVL
   60 CONTINUE
      IF(IP.LT.I) THEN
         K1=I+1
         GO TO 50
      ENDIF
      READ(NREAD,'(A)',END=100) LINE
      WRITE(NWRITE,'(1X,A)') LINE
      GO TO 20
  100 RETURN
  200 WRITE(NWRITE,*) ' SYNTAX ERROR : INTEGER NUMBER MUST APPEAR'
      WRITE (*,*) CHAR (7) 
      STOP
      END

      SUBROUTINE OPENFILE
      IMPLICIT INTEGER*2  (I-N)
C
      COMMON/IO/NREAD,NWRITE,INDIC
      COMMON/TAPDAT/OLDDAT,NEWDAT
      INTEGER*2  OLDDAT,NEWDAT
C
      CHARACTER*128 PARS
CY      INTEGER*4 NARGS
      INTEGER*4 IARGC
CY      INTEGER*2 I, STATUS
      INTEGER*2 I
C
      NREAD=1
      NWRITE=7
      NEWDAT=20
      OLDDAT=2
      INDIC=10
C
CY      I = NARGS () - 1
      I = IARGC()
      IF (I .LT. 4) GOTO 800
C
      I = 1
CY      CALL GETARG (I, PARS, STATUS)
CY      IF (STATUS .LE. 0)  GOTO 810
      CALL GETARG (I, PARS)
      IF (PARS(1:1).EQ.' ')  GOTO 810
C
      OPEN (NREAD,FILE=PARS,STATUS='OLD',ACCESS='SEQUENTIAL',
     $              FORM='FORMATTED',ERR=820 )
C
      I = 2
CY      CALL GETARG (I, PARS, STATUS)
CY      IF (STATUS .LE. 0)  GOTO 810
      CALL GETARG (I, PARS)
      IF (PARS(1:1).EQ.' ')  GOTO 810
C
      OPEN (OLDDAT,FILE=PARS,STATUS='OLD',ACCESS='SEQUENTIAL',
     $              FORM='FORMATTED',ERR=820 )
C
      I = 3
CY      CALL GETARG (I, PARS, STATUS)
CY      IF (STATUS .LE. 0)  GOTO 810
      CALL GETARG (I, PARS)
      IF (PARS(1:1).EQ.' ')  GOTO 810
C
      OPEN (NWRITE,FILE=PARS,ACCESS='SEQUENTIAL',
     $              FORM='FORMATTED',ERR=820 )
C
      OPEN (INDIC,FILE='FORT10',STATUS='OLD',ACCESS='SEQUENTIAL',
     $              FORM='UNFORMATTED' )
C
      I = 4
CY      CALL GETARG (I, PARS, STATUS)
CY      IF (STATUS .LE. 0)  GOTO 810
      CALL GETARG (I, PARS)
      IF (PARS(1:1).EQ.' ')  GOTO 810
C
      OPEN (NEWDAT,FILE=PARS,ACCESS='SEQUENTIAL',
     $              FORM='FORMATTED',ERR=820 )
C
      RETURN
C
 800  WRITE (*,900) I, CHAR(7)
      GOTO 850
C
 810  WRITE (*,920) CHAR(7)
      GOTO 850
C
CY 820  WRITE (*,910) PARS (1:STATUS), CHAR(7)
 820  WRITE (*,910) PARS, CHAR(7)
      GOTO 850
C
 850  STOP 2
C
 900  FORMAT (' *** ERROR ***  only ', I1,
     1        ' parameters supplied - 4 required.', A1)
 910  FORMAT (' *** ERROR *** opening file ', A, A1)
 920  FORMAT (' *** ERROR *** Parameter status error in  GETARG.', A1)
C
      END

